<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Model" referent="RBX0">
		<Properties>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Include</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Script" referent="RBX1">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Option</string>
				<ProtectedString name="Source">--[[
&#9;Option
&#9;Purpose:
&#9;&#9;Create Option functions
&#9;&#9;Similiar to roblox enums
&#9;&#9;The name &quot;Option&quot; is chosen in order to prevent confusion
&#9;&#9;Roblox uses enums
&#9;&#9;Instinct uses options
&#9;
--]]

-- DEFINE ALL OPTIONS HERE!

local Options = {}

local opt_meta = {}

function opt_meta:__tostring()
&#9;return &quot;Option.&quot;..self[1]..self[2]
end

function Options.New(option_type, option_list)
&#9;Options[option_type] = {}
&#9;for i,v in pairs(option_list) do
&#9;&#9;Options[option_type][v] = {option_type, v}
&#9;&#9;Options[option_type][i] = Options[option_type][v]
&#9;&#9;setmetatable(Options[option_type][v], opt_meta) -- tostring
&#9;end
end

-- 

Options.New(&quot;ConsolePriority&quot;, {&quot;Low&quot;, &quot;Normal&quot;, &quot;High&quot;, &quot;Extreme&quot;})

return true</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX2">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Instinct</string>
				<ProtectedString name="Source">--[[
&#9;Instinct
&#9;&#9;Loads the Framework
&#9;&#9;
&#9;Usage:
&#9;&#9;require(Instinct).Load(&quot;Client&quot; | &quot;Server&quot;)
&#9;&#9;This will setup the Instinct Framework environment
&#9;&#9;in the Instinct namespace
--]]

-- Probe environment

local pre = _G.__InstinctPresets
local ltype
if pre then
&#9;ltype = pre.LoadType
end

if not pre then
&#9;error(&quot;[Instinct Master Error] Could not load Instinct, _G.__InstinctPresests is not defined.&quot;)
end

if not ltype then
&#9;error(&quot;[Instinct Master Error] Could not find LoadType, Instinct cannot load.&quot;)
end

-- Define Instinct lib
_G.Instinct = {} 
local Instinct = _G.Instinct

Instinct.Global = [=[
Version
Option
Create
Services/Locale
Event
]=]

Instinct.Client = [=[
Console
Menu
Utilities/Palette
Gui/Window
Gui/SelectionMenu
]=]

Instinct.Server = [=[
Utilities/ColorTools
Utilities/Palette
]=]



local root = game:GetService(&quot;ReplicatedStorage&quot;).Instinct

--[[ Instinct.Load
&#9;@arg1: List (newline seperated module load list)
--]]
function Instinct.Load(List, only)
&#9;for ModuleName in List:gmatch(&quot;[^\n]+&quot;) do 
&#9;&#9;local newroot = root
&#9;&#9;local objpointer = Instinct -- pointer to the table 
&#9;&#9;local previous = objpointer
&#9;&#9;for NameMatch in ModuleName:gmatch(&quot;(%w+)/?&quot;) do
&#9;&#9;&#9;local try = newroot:FindFirstChild(NameMatch)
&#9;&#9;&#9;if try then
&#9;&#9;&#9;&#9;newroot = try
&#9;&#9;&#9;&#9;if try:IsA(&quot;Model&quot;) and not objpointer[try.Name] then 
&#9;&#9;&#9;&#9;&#9;objpointer[try.Name] = {} 
&#9;&#9;&#9;&#9;&#9;objpointer = objpointer[try.Name]
&#9;&#9;&#9;&#9;&#9;previous = objpointer
&#9;&#9;&#9;&#9;elseif try:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;&#9;objpointer = objpointer[try.Name]
&#9;&#9;&#9;&#9;&#9;previous = objpointer
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;newroot = nil 
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end&#9;
&#9;&#9;end
&#9;&#9;if newroot and newroot:IsA(&quot;ModuleScript&quot;) and previous then 
&#9;&#9;&#9;local Name = newroot.Name
&#9;&#9;&#9;print(&quot;Info&quot;, &quot;Load: &quot;..Name, newroot:GetFullName())
&#9;&#9;&#9;local out = require(newroot)
&#9;&#9;&#9;if type(out) == &quot;table&quot; and Instinct.Create and not out.__noreg then
&#9;&#9;&#9;&#9;Instinct.Create.Register(out)
&#9;&#9;&#9;&#9;Instinct.Create.RegisterClassName(Name, out)
&#9;&#9;&#9;end
&#9;&#9;&#9;previous[Name] = out
&#9;&#9;&#9;if only then 
&#9;&#9;&#9;&#9;return out
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;print(&quot;Error&quot;, &quot;Load: Unable to load module: &quot;..ModuleName..&quot;, module does not exist!&quot;)
&#9;&#9;end
&#9;end
end

function Instinct.Include(name)
&#9;return Instinct.Load(name, true)
end

function Instinct.Initialize(mode)
&#9;if mode == &quot;Server&quot; then
&#9;&#9;Instinct.Client = nil
&#9;&#9;Instinct.Load(Instinct.Global)
&#9;&#9;Instinct.Load(Instinct.Server)
&#9;elseif mode == &quot;Client&quot; then
&#9;&#9;Instinct.Server = nil
&#9;&#9;Instinct.Load(Instinct.Global)
&#9;&#9;Instinct.Load(Instinct.Client)
&#9;end
end

Instinct.Initialize(ltype)

return Instinct</ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX3">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Services</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX4">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Locale</string>
					<ProtectedString name="Source">local Locale = {}

Locale.Default = &quot;English&quot;

Locale.Selected = &quot;English&quot;

Locale.AvailableLocales = {
&#9;--&quot;Francais&quot;,
&#9;--&quot;Deutsch&quot;,
&#9;&quot;English&quot;,
&#9;--&quot;Espanol&quot;,
&#9;--&quot;Italiano&quot;,&#9;
&#9;&quot;Nederlands&quot;,
}

Locale.DefaultLocale = Instinct.Include(&quot;LocaleFiles/&quot;..Locale.Default)
Locale.SelectedLocale = Locale.DefaultLocale

function Locale.Get(str)
&#9;-- BOOM TRANSLATIONS &lt;3
&#9;return Locale.SelectedLocale[str] or Locale.DefaultLocale or (str..&quot;&gt;MISSING!&quot;)
end

function Locale.Set(lang)
&#9;local found = false
&#9;for i,v in pairs(Locale.AvailableLocales) do
&#9;&#9;if v == lang then
&#9;&#9;&#9;local try = Instinct.Include(&quot;LocaleFiles/&quot;..v)
&#9;&#9;&#9;if try then
&#9;&#9;&#9;&#9;Locale.SelectedLocale = try
&#9;&#9;&#9;&#9;found = true
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;print(&quot;[Instinct Core] Locale not found: &quot;..tostring(v))
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if not found then
&#9;&#9;print(&quot;[Instinct Core] Locale not found: &quot;..tostring(lang))
&#9;end
end

return Locale</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX5">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Create</string>
				<ProtectedString name="Source">--[[
&#9;Create
&#9;Purpose: 
&#9;&#9;Return utilites&#9;
&#9;
&#9;
--]]

local Create = {}

Create.__index = function(tab, index, value)
&#9;return tab
end

Create.__call = function(tab, ...)
&#9;if tab.Call then
&#9;&#9;return tab.Call(...)
&#9;end
end

Create.__newindex = function(tab, index, value)
&#9;if index == &quot;Parent&quot; and type(value) == &quot;table&quot; then
&#9;&#9;if tab.Parent then
&#9;&#9;&#9;local id = tab.__childid
&#9;&#9;&#9;value.__children[id] = nil
&#9;&#9;end
&#9;&#9;if not value.__children then 
&#9;&#9;&#9;value.__children = {}
&#9;&#9;end
&#9;&#9;table.insert(value.__children, tab)
&#9;&#9;rawset(tab, &quot;Parent&quot;, value)
&#9;&#9;rawset(tab, &quot;__childid&quot;, #value.__children - 1)
&#9;else
&#9;&#9;rawset(tab,index,value)
&#9;end
end

Create.__index = function(tab, index, value)
&#9;local root = rawget(tab, &quot;__root&quot;)
&#9;if root then 
&#9;&#9;local ri = root[index]
&#9;&#9;if ri then
&#9;&#9;&#9;return ri
&#9;&#9;end
&#9;&#9;local ext = root.__extend
&#9;&#9;if ext then 
&#9;&#9;&#9;return ext[value] -- Recursive
&#9;&#9;end
&#9;end
end

Create.Classes = {}

function Create.RegisterClassName(ClassName, data)
&#9;if not Create.Classes[ClassName] then
&#9;&#9;Create.Classes[ClassName] = data
&#9;else
&#9;&#9;print(&quot;[Instinct Error] Conflicting ClassNames: &quot;..ClassName .. &quot; (ClassName already registered)&quot;)
&#9;end
end

function Create.Class() -- returns an empty class handler
&#9;local new = {}
&#9;return setmetatable(new, RegisterMeta)
end

function Create.Call(object)
&#9;local new = {}
&#9;local obj
&#9;if type(object) == &quot;string&quot; then
&#9;&#9;local cdata = Create.Classes[object]
&#9;&#9;if cdata then
&#9;&#9;&#9;obj = cdata
&#9;&#9;end
&#9;elseif type(object) == &quot;table&quot; then
&#9;&#9;obj = object
&#9;end
&#9;if not obj then
&#9;&#9;print(&quot;[Instinct Error] Could not load object: &quot;..tostring(object))
&#9;&#9;return nil
&#9;end
&#9;new.__root = obj
&#9;setmetatable(new, Create)
&#9;if new.Constructor then 
&#9;&#9;new:Constructor()
&#9;end
&#9;return new
end

-- Instinct.Create.Extend(Fruit, Banana)
function Create.Extend(with, class)
&#9;class.__extend = with
end

local RegisterMeta = {}

function RegisterMeta.__index(tab, index)
&#9;local ext = rawget(tab, &quot;__extend&quot;) 
&#9;if ext then 
&#9;&#9;return ext[index]
&#9;end
end

function Create.Register(class) -- Needed to assign the metatables
&#9;return setmetatable(class, RegisterMeta)
end

setmetatable(Create,Create)


return Create</ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX6">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Utilities</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX7">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Palette</string>
					<ProtectedString name="Source">local Palette = {}



local ct = Instinct.Include(&quot;Utilities/ColorTools&quot;)

local rgb = ct.RGBToColor3


Palette.Data = {
&#9;Default = {
&#9;&#9;Default = rgb( 43,125, 43),
&#9;&#9;Shade1 = rgb(120,186,120),
&#9;&#9;Shade2 = rgb( 73,151, 73),
&#9;&#9;Shade3 = rgb( 20, 95, 20),
&#9;&#9;Shade4 = rgb(  2, 63,  2),
&#9;},
&#9;Shade1 ={
&#9;&#9;Default = rgb( 32, 94, 94),
&#9;&#9;Shade1 = rgb( 90,140,140),
&#9;&#9;Shade2 = rgb( 54,113,113),
&#9;&#9;Shade3 = rgb( 15, 72, 72),
&#9;&#9;Shade4 = rgb(  2, 47, 47),
&#9;},
&#9;Shade2 = {
&#9;&#9;Default = rgb(114,146, 51),
&#9;&#9;Shade1 = rgb(191,217,140),
&#9;&#9;Shade2 = rgb(146,177, 85),
&#9;&#9;Shade3 = rgb( 82,111, 23),
&#9;&#9;Shade4 = rgb( 50, 73,  3),
&#9;},
&#9;Complement = {
&#9;&#9;Default = rgb(156, 54, 54),
&#9;&#9;Shade1 = rgb(233,150,150),
&#9;&#9;Shade2 = rgb(189, 91, 91),
&#9;&#9;Shade3 = rgb(119, 25, 25),
&#9;&#9;Shade4 = rgb( 78,  3,  3),
&#9;},
&#9;Console = {
&#9;&#9;Default = rgb(0,0,0),
&#9;&#9;Text = rgb(255,255,255),
&#9;},
&#9;Text = {
&#9;&#9;Default = rgb(0,0,0),
&#9;&#9;White = rgb(255,255,255)
&#9;},
&#9;Background = {
&#9;&#9;Default = rgb(0,0,0),
&#9;&#9;Shade1 = rgb(20,20,20),
&#9;&#9;Shade2 = rgb(40,40,40),
&#9;&#9;Shade3 = rgb(60,60,60),
&#9;&#9;Shade4 = rgb(80,80,80),
&#9;},
&#9;SFX = {
&#9;&#9;Default = rgb(0,0,0), -- shade color
&#9;},
&#9;ColorLabel = { -- colorlabel tags!
&#9;&#9;black = rgb(0,0,0),
&#9;&#9;red = rgb(128,0,0),
&#9;&#9;green = rgb(0,128,0),
&#9;&#9;yellow = rgb(128,128,0),
&#9;&#9;blue = rgb(0,0,128),
&#9;&#9;purple = rgb(128,0,128),
&#9;&#9;cyan = rgb(0,128,128),
&#9;&#9;white = rgb(192,192,192)
&#9;&#9;
&#9;&#9;
&#9;},
&#9;ColorLabelLight = {
&#9;&#9;black = rgb(128,128,128),
&#9;&#9;red = rgb(255,0,0),
&#9;&#9;green = rgb(0,255,0),
&#9;&#9;yellow = rgb(255,255,0),
&#9;&#9;blue = rgb(0,0,255),
&#9;&#9;purple = rgb(255,0,255),
&#9;&#9;cyan = rgb(0,255,255),
&#9;&#9;white = rgb(255,255,255)&#9;&#9;
&#9;&#9;
&#9;}
&#9;
&#9;
&#9;--[[ 0 #000000  1 #800000  2 #008000  3 #808000  4 #000080  5 #800080  6 #008080  7 #c0c0c0
 8 #808080  9 #ff0000 10 #00ff00 11 #ffff00 12 #0000ff 13 #ff00ff 14 #00ffff 15 #ffffff--]]
}

function Palette:Get(Type, Which)
&#9;local Type = Type or &quot;Default&quot;
&#9;local Which = Which or &quot;Default&quot;
&#9;if self.Data and self.Data[Type] then 
&#9;&#9;return self.Data[Type][Which] or self.Data[Type].Default 
&#9;else 
&#9;&#9;return self.Data.Default[Which] or self.Data.Default.Default
&#9;end
end

function Palette:GetRaw(Type, Which) -- can return nil! raw checks
&#9;return self.Data[Type] and self.Data[Type][Which]
end

return Palette</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX8">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ColorTools</string>
					<ProtectedString name="Source">local ColorTools = {}

function ColorTools.RGBToColor3(r,g,b)
&#9;return Color3.new(r/255,g/255,b/255)
end

return ColorTools</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX9">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Date</string>
					<ProtectedString name="Source">local Date = {}

Date.Constants = {
&#9;millisecond = 0.001,
&#9;second = 1,
&#9;minute = second * 60,
&#9;hour = minute * 60,
&#9;day = hour * 24,
&#9;week = day * 7,
&#9;year = day * 365,
&#9;lyear = day * 366,
&#9;lsyear = day * 366 + second,
&#9;syear = day * 365,
}

Date.Months = {
&#9;{&quot;Jan&quot;, 31}, {&quot;Feb&quot;, 28},
&#9;{&quot;Mar&quot;, 31}, {&quot;Apr&quot;, 30},
&#9;{&quot;May&quot;, 31}, {&quot;Jun&quot;, 31},
&#9;{&quot;Jul&quot;, 31}, {&quot;Aug&quot;, 30},
&#9;{&quot;Sep&quot;, 31}, {&quot;Oct&quot;, 30},
&#9;{&quot;Nov&quot;, 31}, {&quot;Dec&quot;, 30}&#9;
}

Date.Start = 30 * Date.Constants.year + 7 * Date.Constants.day -- 2000 start

function Date.YearIsLeap(year) -- a full year
&#9;return (year % 4) == 0
end

function Date.UnixToDate(time)
&#9;local time = math.floor( ( time or os.time() ) + 0.5)
&#9;-- 1 january 1970 00:00:00 -&gt; 0
&#9;local from2000 = time - Date.Start
&#9;
&#9;local yearsleft = from2000 % ( Date.Constants.year&#9;)
&#9;from2000 = from2000 - yearsleft * Date.Constants.year
&#9;
&#9;
end

return Date</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX10">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Version</string>
				<ProtectedString name="Source">return &quot;0.0.275&quot;</ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX11">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Gui</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX12">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ButtonBar</string>
					<ProtectedString name="Source">local ButtonBar = {}

local Dim = Instinct.Include &quot;Gui/DimTools&quot;
local Presets = Instinct.Include &quot;Gui/GuiPresets&quot;

ButtonBar.Font = &quot;ArialBold&quot;
ButtonBar.FontSize = &quot;Size12&quot;
ButtonBar.WhiteSpace = 5
ButtonBar.Shade = 2
ButtonBar.TextWhiteSpace = 10 -- total whitespace

function ButtonBar:Init(where, pos, size)
&#9;local frame = Instance.new(&quot;Frame&quot;, where)
&#9;frame.ClipsDescendants = true
&#9;frame.BackgroundTransparency = 1
&#9;local x_size, y_size = Dim.TextSize(&quot;test&quot;, self.Font, self.FontSize)
&#9;frame.Size = size or UDim2.new(1,0, 0, y_size + self.Shade)
&#9;frame.Position = pos or UDim2.new(0,0,0,0)
&#9;self.Root = frame
end


function ButtonBar:AddButton(name)
&#9;local button = Presets.Button(self.Shade)
&#9;button.Parent = self.Root
&#9;local max_x = -math.huge
&#9;for i,v in pairs(self.Root:GetChildren()) do
&#9;&#9;if v.Position.X.Offset + v.AbsoluteSize.X &gt; max_x then
&#9;&#9;&#9;max_x = v.Position.X.Offset + v.AbsoluteSize.X
&#9;&#9;end
&#9;end
&#9;
&#9;local new = max_x + self.WhiteSpace
&#9;local size, ysize = Dim.TextSize(name, self.Font, self.FontSize)
&#9;button.Size = UDim2.new(0, size + self.TextWhiteSpace, 0, ysize)
&#9;button.Position = UDim2.new(0,new,0,0)
&#9;button.Text = name 
&#9;
&#9;return button
end

return ButtonBar</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX13">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DimTools</string>
					<ProtectedString name="Source">-- DimTools define functions for moving and reszing GUIs around
-- They dont respect the parent GUIs

local DimTools = {}

function DimTools.Center(Gui)
&#9;Gui.Position = UDim2.new(0.5 - (Gui.Size.X.Scale/2), -Gui.Size.X.Offset * 0.5, 0.5 - (Gui.Size.Y.Scale/2), -Gui.Size.Y.Offset * 0.5)
end

function DimTools.TextSize(text, font, fontsize)
&#9;if not game.Players.LocalPlayer.PlayerGui:FindFirstChild(&quot;FontCHK&quot;) then 
&#9;&#9;local new = Instance.new(&quot;ScreenGui&quot;, game.Players.LocalPlayer.PlayerGui)
&#9;&#9;new.Name = &quot;FontCHK&quot;
&#9;&#9;local x = Instance.new(&quot;TextButton&quot;, new)
&#9;&#9;x.Visible = false
&#9;end
&#9;local my = game.Players.LocalPlayer.PlayerGui.FontCHK.TextButton

&#9;my.FontSize = fontsize
&#9;my.Text = text
&#9;my.Font = font
&#9;if my.TextBounds.X &lt;= 0.99 or my.TextBounds.Y &lt;= 0.99 then
&#9;&#9;repeat wait(1/60) 
&#9;&#9;until my.TextBounds.X &gt;0.99 and my.TextBounds.Y &gt;0.99
&#9;end
&#9;local x = my.TextBounds.X
&#9;local y = my.TextBounds.Y
&#9;return x, y
end

return DimTools</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX14">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WindowServer</string>
					<ProtectedString name="Source">local WindowServer = {}

WindowServer.Windows = {}

function WindowServer.Notify(Window, StateChange)
&#9;
end

function WindowServer.RequestOpen(WindowName, Button)
&#9;local new
&#9;if WindowServer.Windows[WindowName] then
&#9;&#9;WindowServer.Windows[WindowName]:Toggle()
&#9;else
&#9;&#9;new = Instinct.Create(Instinct.Gui.Window)
&#9;&#9;new:Create()
&#9;&#9;if Button then
&#9;&#9;&#9;new:SetButton(Button)
&#9;&#9;end
&#9;&#9;new:SetTitle(WindowName)
&#9;&#9;new:Open()
&#9;&#9;WindowServer.Windows[WindowName] = new

&#9;end
&#9;for i,v in pairs(WindowServer.Windows) do
&#9;&#9;if i ~= WindowName then
&#9;&#9;&#9;v:Close()
&#9;&#9;end
&#9;end
&#9;return new
end

return WindowServer</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX15">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Window</string>
					<ProtectedString name="Source">local Window = {}

local Palette = Instinct.Include(&quot;Utilities/Palette&quot;)
local Dim = Instinct.Include(&quot;Gui/DimTools&quot;)
local WindowServer = Instinct.Include(&quot;Gui/WindowServer&quot;)
local SFX = Instinct.Include(&quot;Gui/SFX&quot;)

Window.Canvas = nil
Window.Root = nil
Window.DestroyOnClose = false
Window.TitleFont = &quot;ArialBold&quot;
Window.TitleFontSize = &quot;Size18&quot;

local Player = game.Players.LocalPlayer

function Window:Create(Size, Title)
&#9;if Player.PlayerGui:FindFirstChild(&quot;Windows&quot;) == nil then 
&#9;&#9;Instance.new(&quot;ScreenGui&quot;, Player.PlayerGui).Name = &quot;Windows&quot;
&#9;end
&#9;local Root = Player.PlayerGui.Windows
&#9;local new = Instance.new(&quot;Frame&quot;, Root)
&#9;new.BackgroundColor3 = Palette:Get(&quot;Background&quot;, &quot;Shade4&quot;) 
&#9;new.BackgroundTransparency = 0.5
&#9;new.Size = Size or UDim2.new(0.5,0,0.5,0)
&#9;new.BorderSizePixel = 0
&#9;Dim.Center(new)
&#9;-- Create header
&#9;local header = Instance.new(&quot;Frame&quot;, new)
&#9;header.Position = UDim2.new(0,0,0,-20)
&#9;header.Size = UDim2.new(1,0,0,20)
&#9;header.BorderSizePixel = 0
&#9;header.BackgroundColor3 = Palette:Get(&quot;Default&quot;, &quot;Shade4&quot;)
&#9;-- Create title
&#9;local title = Instance.new(&quot;TextLabel&quot;, header)
&#9;title.Position = UDim2.new(0.25, 0, 0, -6)
&#9;title.Size = UDim2.new(0.5, 0, 0, 20)
&#9;title.Text = Title or &quot;&quot;
&#9;title.Font = &quot;ArialBold&quot;
&#9;title.FontSize = &quot;Size18&quot;
&#9;title.TextColor3 = Palette:Get(&quot;Text&quot;)
&#9;title.BorderSizePixel = 0
&#9;title.BackgroundColor3 = Palette:Get(&quot;Default&quot;, &quot;Shade2&quot;)
&#9;self.Title = title
&#9;SFX.Shade(title, 3)
&#9;-- Create buttons
&#9;local close = Instance.new(&quot;TextButton&quot;, header)
&#9;close.Size = UDim2.new(0,30, 0,12)
&#9;close.Position = UDim2.new(1, -40, 0, 4)
&#9;close.Text = &quot;X&quot;
&#9;close.BorderSizePixel = 0
&#9;close.TextColor3 = Palette:Get(&quot;Text&quot;, &quot;Default&quot;)
&#9;close.BackgroundColor3 = Palette:Get(&quot;Complement&quot;, &quot;Default&quot;)
&#9;close.MouseButton1Click:connect(function()
&#9;&#9;WindowServer:Notify(new, &quot;Close&quot;)
&#9;&#9;self:Close()
&#9;end)
&#9;SFX.Shade(close, 2)
&#9;self.Canvas = new
end

function Window:Close()
&#9;self.Canvas.Visible = false
&#9;self.State = &quot;Closed&quot;
&#9;if self.Button then
&#9;&#9;self.Button.BackgroundColor3 = Palette:Get(&quot;Complement&quot;)
&#9;end
&#9;if self.CloseCallback then
&#9;&#9;self.CloseCallback()
&#9;end
&#9;if self.DestroyOnClose then
&#9;&#9;self.Canvas:Destroy()
&#9;end
end

function Window:Open()
&#9;self.Canvas.Visible = true
&#9;self.State = &quot;Open&quot;
&#9;if self.Button then
&#9;&#9;self.Button.BackgroundColor3 = Palette:Get(&quot;Shade1&quot;)
&#9;end
&#9;if self.OpenCallback then 
&#9;&#9;self.OpenCallback()
&#9;end
end

function Window:SetButton(Button)
&#9;self.Button = Button
end

function Window:Toggle()
&#9;if self.State == &quot;Open&quot; then
&#9;&#9;self:Close()
&#9;else
&#9;&#9;self:Open()
&#9;end
end

function Window:SetTitle(title)
&#9;self.Title.Text = title
end

return Window</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX16">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SFX</string>
					<ProtectedString name="Source">local SFX = {}

local Palette = Instinct.Include(&quot;Utilities/Palette&quot;)

function SFX.Shade(which, size)
&#9;local size = size or 3
&#9;local shadeunder = Instance.new(&quot;Frame&quot;, which)
&#9;shadeunder.BorderSizePixel = 0
&#9;shadeunder.BackgroundColor3 = Palette:Get(&quot;SFX&quot;, &quot;Default&quot;)
&#9;shadeunder.Name = &quot;Shade&quot;
&#9;local shaderight = shadeunder:Clone()
&#9;shaderight.Parent = which
&#9;shaderight.Size = UDim2.new(0,size,1,0)
&#9;shadeunder.Size = UDim2.new(1,0,0,size)
&#9;shaderight.Position = UDim2.new(1,0,0,size)
&#9;shadeunder.Position = UDim2.new(0,size,1,0)
&#9;
end

function SFX.RemoveShade(which)
&#9;for i,v in pairs(which:GetChildren()) do
&#9;&#9;if v:IsA(&quot;Frame&quot;) and v.Name == &quot;Shade&quot; then
&#9;&#9;&#9;v:Destroy()
&#9;&#9;end
&#9;end
end

function SFX.MakeBorder(which, left, right, up, down, color, bordersize)
&#9;function get()
&#9;&#9;local new = Instance.new(&quot;Frame&quot;, which)
&#9;&#9;new.BackgroundColor3 = color
&#9;&#9;new.BorderSizePixel = 0
&#9;&#9;new.Name = &quot;Border&quot;
&#9;&#9;return new
&#9;end
&#9;-- left
&#9;if left then 
&#9;local x = get()
&#9;local yoffset = -((up and bordersize) or 0)
&#9;x.Position = UDim2.new(0, -bordersize, 0, yoffset)
&#9;x.Size = UDim2.new(0, bordersize, 1, -yoffset + ((down and bordersize) or 0))
&#9;end
&#9;-- right
&#9;if right then
&#9;local x = get()
&#9;local yoffset = -((up and bordersize) or 0)
&#9;x.Position = UDim2.new(1,0,0, yoffset)
&#9;x.Size = UDim2.new(0, bordersize, 1, -yoffset + ((down and bordersize) or 0))
&#9;end
&#9;-- down
&#9;if down then 
&#9;local y = get()
&#9;local xoffset = -((left and bordersize) or 0)
&#9;y.Position = UDim2.new(0,xoffset,1, 0)
&#9;y.Size = UDim2.new(1, xoffset + ((right and bordersize) or 0), 0, bordersize)
&#9;end
&#9;-- up
&#9;if up then 
&#9;local y = get()
&#9;local xoffset = -((left and bordersize) or 0)
&#9;y.Position = UDim2.new(0,xoffset,0, -bordersize)
&#9;y.Size = UDim2.new(0, xoffset + ((right and bordersize) or 0), 0, bordersize)
&#9;end&#9;
end

return SFX</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX17">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DropDown</string>
					<ProtectedString name="Source">local DropDown = {}

DropDown.XOffset = 10
DropDown.YOffset = 5
DropDown.TextOffset = 5
DropDown.Shade = 2

local SFX = Instinct.Include(&quot;Gui/SFX&quot;)
local Presets = Instinct.Include(&quot;Gui/GuiPresets&quot;)
local Dim = Instinct.Include(&quot;Gui/DimTools&quot;)

function DropDown:Create(Parent, Position, BackgroundC3, BorderC3, BorderSize)
&#9;local new = Presets.Canvas(BackgroundC3)
&#9;new.Position = Position or UDim2.new(0,0,0,0)
&#9;new.Parent = Parent
&#9;if type(BorderSize) == &quot;table&quot; then
&#9;&#9;local need = { &quot;left&quot;, &quot;right&quot;, &quot;down&quot;, &quot;up&quot;, &quot;bordersize&quot;}
&#9;&#9;local wrong = false
&#9;&#9;for i,v in pairs(need) do 
&#9;&#9;&#9;if BorderSize[v] == nil then 
&#9;&#9;&#9;&#9;wrong = true
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not wrong then
&#9;&#9;&#9;SFX.MakeBorder(new, BorderSize.left, BorderSize.right, BorderSize.up, BorderSize.down, BorderC3, BorderSize.bordersize)
&#9;&#9;end
&#9;else
&#9;&#9;new.BorderSizePixel = BorderSize or 0
&#9;&#9;new.BorderColor3 = BorderC3 or Palette:Get()
&#9;end
&#9;&#9;
&#9;self.Root = new
end

function DropDown:AddButton(text)
&#9;local new = Presets.Button(self.Shade)
&#9;local numbuttons = 0
&#9;for i,v in pairs(self.Root:GetChildren()) do
&#9;&#9;if v.Name ~= &quot;Border&quot; then
&#9;&#9;&#9;numbuttons = numbuttons + 1
&#9;&#9;end
&#9;end
&#9;local ypos = (self.YOffset + self.Shade + new.Size.Y.Offset) * numbuttons + self.YOffset
&#9;new.Text = text
&#9;new.FontSize = &quot;Size12&quot;
&#9;local xt, yt = Dim.TextSize(text, &quot;ArialBold&quot;, &quot;Size12&quot;)
&#9;new.Size = UDim2.new(0, xt + self.TextOffset * 2, 0, new.Size.Y.Offset)
&#9;new.Position = UDim2.new(0, self.XOffset, 0, ypos)
&#9;new.Parent = self.Root
&#9;local max_x = 0
&#9;for i,v in pairs(self.Root:GetChildren()) do
&#9;&#9;if v.Name ~= &quot;Border&quot; then 
&#9;&#9;&#9;local new_x = self.XOffset * 2 + v.Size.X.Offset
&#9;&#9;&#9;if new_x &gt; max_x then
&#9;&#9;&#9;&#9;max_x = new_x
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;for i,v in pairs(self.Root:GetChildren()) do
&#9;&#9;if v.Name ~= &quot;Border&quot; then 
&#9;&#9;&#9;v.Size = UDim2.new(0, max_x - self.XOffset * 2, 0, new.Size.Y.Offset)
&#9;&#9;end
&#9;end
&#9;local ysize = ypos + new.Size.Y.Offset + self.Shade + self.YOffset
&#9;self.Root.Size = UDim2.new(0,max_x, 0, ysize)
&#9;
&#9;return new
&#9;
end


function DropDown:Destroy()
&#9;self.Root:Destroy()
end

return DropDown</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX18">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GuiPresets</string>
					<ProtectedString name="Source">local GuiPresets = {}

local Palette = Instinct.Include(&quot;Utilities/Palette&quot;)
local SFX = Instinct.Include(&quot;Gui/SFX&quot;)
local Dim = Instinct.Include &quot;Gui/DimTools&quot;

function GuiPresets.Button(shade)
&#9;local DropDown = Instance.new(&quot;TextButton&quot;)
&#9;DropDown.BackgroundColor3 = Palette:Get(&quot;Complement&quot;)
&#9;DropDown.TextColor3 = Palette:Get(&quot;Text&quot;)
&#9;DropDown.Font = &quot;ArialBold&quot;
&#9;DropDown.Text = &quot;&quot;
&#9;DropDown.BorderSizePixel = 0
&#9;DropDown.Size = UDim2.new(0,10,0,20)
&#9;DropDown.FontSize = &quot;Size12&quot;
&#9;if shade then 
&#9;&#9;SFX.Shade(DropDown,shade)
&#9;end
&#9;return DropDown
end

-- for easy creationz
-- returns button, xsize, ysize
-- omg it so awesome
function GuiPresets.CustomButton(ButtonText, ButtonShade, ButtonFont, ButtonFontSize, TextColor, BackgroundColor, WhiteSpace)
&#9;local ButtonText = ButtonText or &quot;&quot;
&#9;local ButtonShade = ButtonShade or 0
&#9;local ButtonFont = ButtonFont or &quot;ArialBold&quot;
&#9;local ButtonFontSize = ButtonFontSize or &quot;Size12&quot;
&#9;local TextColor = TextColor or Palette:Get(&quot;Text&quot;)
&#9;local BackgroundColor = BackgroundColor or Palette:Get(&quot;Complement&quot;)
&#9;local WhiteSpace = WhiteSpace or 10&#9;
&#9;local new = Instance.new(&quot;TextButton&quot;)
&#9;new.Text = ButtonText
&#9;new.Font = ButtonFont
&#9;new.FontSize = ButtonFontSize
&#9;new.TextColor3 = TextColor
&#9;new.BackgroundColor3 = BackgroundColor
&#9;new.BorderSizePixel = 0
&#9;if ButtonShade &gt; 0 then
&#9;&#9;SFX.Shade(new, ButtonShade)
&#9;end
&#9;local size_x , size_y = Dim.TextSize(ButtonText, ButtonFont, ButtonFontSize)
&#9;local rs = size_x + WhiteSpace
&#9;new.Size = UDim2.new(0, rs, 0, size_y)
&#9;return new, rs, size_y 
&#9;
end

function GuiPresets.Canvas(color)
&#9;local canvas = Instance.new(&quot;Frame&quot;)
&#9;canvas.BackgroundColor3 = color or Palette:Get()
&#9;canvas.BorderSizePixel = 0
&#9;return canvas
end

function GuiPresets.Backdrop(bsize)
&#9;local bar = Instance.new(&quot;Frame&quot;)
&#9;bar.Size=UDim2.new(0,0,0,0)
&#9;bar.BorderSizePixel = bsize
&#9;bar.BorderColor3 = Palette:Get(&quot;Default&quot;, &quot;Shade4&quot;)
&#9;bar.BackgroundColor3 = Palette:Get(&quot;Default&quot;, &quot;Shade1&quot;)&#9;
&#9;return bar
end


return GuiPresets</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX19">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SelectionMenu</string>
					<ProtectedString name="Source">local Window = Instinct.Include(&quot;Gui/Window&quot;)
local Palette = Instinct.Include(&quot;Utilities/Palette&quot;)
local SFX = Instinct.Include(&quot;Gui/SFX&quot;)
local DimTools = Instinct.Include &quot;Gui/DimTools&quot;
local GuiPresets = Instinct.Include &quot;Gui/GuiPresets&quot;

-- Selecitonmenu builds a GUI with a list of items
-- The user selects and item (highlights)
-- Once OK is clicked the SelectionMenu.Selected will fire:
--&gt; button text AND button instnace as argument
--&gt; NIL if the user did NOT SELECT ANYTHING
--&gt; A close button will also be generated; this will do the same

local SelectionMenu = {}


-- Style

-- Size offset per text item
SelectionMenu.SelectionOffset = 6

-- Color map -&gt; index % 2 + 1 -&gt; color index in color table
--&gt; used as background color
SelectionMenu.Colors = {
&#9;Palette:Get(&quot;Shade2&quot;, &quot;Shade1&quot;),
&#9;Palette:Get(&quot;Shade2&quot;, &quot;Shade2&quot;),
}

SelectionMenu.SelectionColor = Palette:Get(&quot;Shade1&quot;, &quot;Shade1&quot;)

-- Shades the selection 
-- &gt;= selectionoffset to prevent overflows
SelectionMenu.Shade = 0


-- Horizontal total whitespace per selection
-- On the left side (and right size) this / 2


SelectionMenu.HorizontalWS = 10

-- Vertical space; how much offset between window title, the items, the OK button and the end

SelectionMenu.VerticalSpace = 5

SelectionMenu.OKColor = Palette:Get(&quot;Complement&quot;)
SelectionMenu.CreateOK = true


SelectionMenu.TextWS = 10

function SelectionMenu:Constructor()
&#9;
&#9;self.SelectionDone = Instinct.Create(Instinct.Event)
end



-- No tooltip supported yet
function SelectionMenu:CreateWindow(ItemList, Title, DefaultSelection, Description) 
&#9;assert(ItemList, &quot;No itemlist provided&quot;)
&#9;local Window = Instinct.Create(Instinct.Gui.Window)&#9;
&#9;Window.DestroyOnClose = true
&#9;
&#9;
&#9;-- Create a list of text bound items
&#9;
&#9;local TextBounds = {} -- only horizontal
&#9;
&#9;local button = GuiPresets.Button()
&#9;local max = 0
&#9;local tmax = 0&#9;
&#9;
&#9;function chk(txt)
&#9;&#9;local s =  DimTools.TextSize(txt, button.Font, button.FontSize)
&#9;&#9;TextBounds[txt] = s
&#9;&#9;if s &gt; max then
&#9;&#9;&#9;max = s
&#9;&#9;end
&#9;end
&#9;
&#9;for i,v in pairs(ItemList) do
&#9;&#9;chk(v)
&#9;end
&#9;
&#9;chk &quot;OK&quot;&#9;
&#9;
&#9;local TitleSizeMinimum = DimTools.TextSize(Title or &quot;Select an item...&quot;, Window.TitleFont, Window.TitleFontSize)

&#9;if (TitleSizeMinimum) * 0.5 &gt; max then
&#9;&#9;max = TitleSizeMinimum * 2
&#9;end
&#9;
&#9;local ysize_needed = 4 * self.VerticalSpace + (#ItemList * (button.Size.Y.Offset + self.SelectionOffset))&#9;
&#9;
&#9;Window:Create(UDim2.new(0, max + self.HorizontalWS + self.TextWS , 0,  ysize_needed), Title or &quot;Select an item...&quot;)
&#9;
&#9;local curry = self.VerticalSpace -- yum
&#9;
&#9;
&#9;
&#9;for i,v in pairs(ItemList) do
&#9;&#9;&#9;-- Selection Item
&#9;&#9;&#9;local color_index = ( i % 2 ) + 1
&#9;&#9;&#9;local color = self.Colors[color_index]
&#9;&#9;&#9;local cl = button:Clone()
&#9;&#9;&#9;cl.Parent = Window.Canvas
&#9;&#9;&#9;cl.Position = UDim2.new(0, self.HorizontalWS/2, 0, curry)
&#9;&#9;&#9;cl.Size = UDim2.new(0, max + self.TextWS, 0, cl.Size.Y.Offset)
&#9;&#9;&#9;cl.BackgroundColor3 = color
&#9;&#9;&#9;cl.Text = v
&#9;&#9;&#9;if v == DefaultSelection and not self.SelectedButton then 
&#9;&#9;&#9;&#9;self:ChangeSelection(cl)
&#9;&#9;&#9;end
&#9;&#9;&#9;cl.MouseButton1Click:connect(function() self:ChangeSelection(cl) end)
&#9;&#9;&#9;curry = curry + cl.Size.Y.Offset + self.SelectionOffset
&#9;end
&#9;if self.CreateOK then 
&#9;&#9;&#9;&#9;-- OK button
&#9;&#9;&#9;curry = curry - self.SelectionOffset + self.VerticalSpace
&#9;&#9;&#9;local cl = button:Clone()
&#9;&#9;&#9;cl.Parent = Window.Canvas
&#9;&#9;&#9;cl.Position = UDim2.new(0.5, -TextBounds[&quot;OK&quot;]/2,0,curry)
&#9;&#9;&#9;cl.BackgroundColor3 = self.OKColor
&#9;&#9;&#9;cl.Text = &quot;OK&quot;
&#9;&#9;&#9;cl.Size = UDim2.new(0, TextBounds[&quot;OK&quot;] + self.TextWS, 0, cl.Size.Y.Offset)
&#9;&#9;&#9;SFX.Shade(cl, self.Shade)
&#9;&#9;&#9;cl.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;self:Done(true) -- and close window
&#9;&#9;&#9;end)
&#9;end
&#9;self.Window = Window
&#9;Window.CloseCallback = function()
&#9;&#9;self:Done(false)
&#9;end
end

function SelectionMenu:ChangeSelection(newbutton)
&#9;SFX.Shade(newbutton, self.Shade)
&#9;if self.SelectedButton then 
&#9;&#9;SFX.RemoveShade(self.SelectedButton)
&#9;&#9;self.SelectedButton.BackgroundColor3 = self.OldColor
&#9;end
&#9;self.OldColor = newbutton.BackgroundColor3 
&#9;self.SelectedButton = newbutton
&#9;self.SelectedText = newbutton.Text
&#9;newbutton.BackgroundColor3 = self.SelectionColor
end


function SelectionMenu:Done(do_window_close)
&#9;if not self.CycleDone then 
&#9;&#9;self.CycleDone = true
&#9;&#9;self.SelectionDone:fire(self.SelectedText)
&#9;&#9;if do_window_close then
&#9;&#9;&#9;self.Window:Close()
&#9;&#9;end
&#9;end
end

return SelectionMenu </ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX20">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ScrollText</string>
					<ProtectedString name="Source">local ScrollText = {}

local Window = Instinct.Include &quot;Gui/Window&quot;
local Palette = Instinct.Include &quot;Utilities/Palette&quot;
local Dim = Instinct.Include &quot;Gui/DimTools&quot;
local ColorLabel = Instinct.Include &quot;Gui/ColorLabel&quot;


ScrollText.Font = &quot;ArialBold&quot;
ScrollText.FontSize = &quot;Size12&quot;

ScrollText.TextColor = Palette:Get(&quot;TextColor&quot;, &quot;Black&quot;)

function ScrollText:Create(where, size, pos)
&#9;local new = Instance.new(&quot;Frame&quot;, where)
&#9;new.Size = size or UDim2.new(1,0,1,0)
&#9;new.Position = pos or UDim2.new(0,0,0,0)
&#9;new.ClipsDescendants = true
&#9;new.BackgroundTransparency = 1
&#9;self.Root = new
end

function ScrollText:CreateWindow(size)
&#9;
end

function ScrollText:Push(txt, tcolor)
&#9;local new = Instinct.Create(ColorLabel)
&#9;new.FontSize = self.FontSize
&#9;new.DefaultColor = tcolor or Palette:Get &quot;Text&quot;
&#9;new = new:GetLabel(txt, tcolor or Palette:Get(&quot;Text&quot;))
&#9;new.Position = UDim2.new(0, 0, 1, 0)
&#9;new.Parent = self.Root
&#9;local size_x, size_y = Dim.TextSize(&quot;test&quot;, self.Font, self.FontSize)
&#9;for i,v in pairs(self.Root:GetChildren()) do
&#9;&#9;v.Position = v.Position - UDim2.new(0,0,0,size_y)
&#9;&#9;if v.Position.Y.Offset &lt; -v.Parent.AbsoluteSize.Y then
&#9;&#9;&#9;v:Destroy()
&#9;&#9;end
&#9;end
end

return ScrollText</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX21">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ColorLabel</string>
					<ProtectedString name="Source">local ColorLabel = {}

local Palette = Instinct.Include &quot;Utilities/Palette&quot;
local Dim = Instinct.Include &quot;Gui/DimTools&quot;

ColorLabel.FontSize = &quot;Size12&quot;
ColorLabel.Font = &quot;Arial&quot;
ColorLabel.BoldFont = &quot;ArialBold&quot;

ColorLabel.DefaultColor = Palette:Get(&quot;Text&quot;)

-- Parsing:
-- default escape; %{red light bold}

function ColorLabel:GetElementList(txt)
&#9;-- returns a table with elements to build labels from
&#9;-- ret: {txt, font, fontcolor}
&#9;local out = {}
&#9;local dmode = {self.Font, self.DefaultColor} -- default mode
&#9;local cmode = dmode -- current mode
&#9;local last
&#9;for match, newmode in string.gmatch(txt, &quot;([^%%]*)(%b%})&quot;) do
&#9;&#9;last = newmode
&#9;&#9;table.insert(out, {match, cmode[1], cmode[2]}) --unpack(cmode)
&#9;&#9;cmode = {}
&#9;&#9;local elements = {} -- elements provided;
&#9;&#9;for element in string.gmatch(newmode, &quot;[^{} ]+&quot;) do
&#9;&#9;&#9;elements[element:lower()] = true
&#9;&#9;end
&#9;&#9;if not elements.reset then 
&#9;&#9;&#9;if elements.bold then
&#9;&#9;&#9;&#9;cmode[1] = self.BoldFont
&#9;&#9;&#9;&#9;elements.bold = nil
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;cmode[1] = self.Font
&#9;&#9;&#9;end
&#9;&#9;&#9;local palette = &quot;ColorLabel&quot;
&#9;&#9;&#9;if elements.light then
&#9;&#9;&#9;&#9;palette = &quot;ColorLabelLight&quot;
&#9;&#9;&#9;&#9;elements.light = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;for i,v in pairs(elements) do
&#9;&#9;&#9;&#9;local color = Palette:Get(palette, i) 
&#9;&#9;&#9;&#9;if color then 
&#9;&#9;&#9;&#9;&#9;cmode[2] = color
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else 
&#9;&#9;&#9;cmode = dmode
&#9;&#9;end
&#9;&#9;if not cmode[2] then
&#9;&#9;&#9;cmode[2] = self.DefaultColor
&#9;&#9;end
&#9;end
&#9;local tail 
&#9;if last then 
&#9;&#9;tail = txt:match(&quot;%&quot;..last..&quot;(.-)$&quot;)
&#9;&#9;local test = tail
&#9;&#9;local loop = 0
&#9;&#9;while test do
&#9;&#9;&#9;test = tail:match(&quot;%&quot;..last..&quot;(.-)$&quot;)
&#9;&#9;&#9;if test then
&#9;&#9;&#9;&#9;tail = test
&#9;&#9;&#9;end
&#9;&#9;&#9;loop = loop + 1
&#9;&#9;&#9;if loop &gt; 50 then 
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end 
&#9;end

&#9;if not tail then
&#9;&#9;tail = txt -- no escapes provided, kthen
&#9;end
&#9;table.insert(out, {tail, cmode[1], cmode[2]})
&#9;return out
&#9;
&#9;
end


function ColorLabel:GetLabel(txt,c)
&#9;if c then
&#9;&#9;self.DefaultColor = c
&#9;end
&#9;local list = self:GetElementList(txt)
&#9;local root
&#9;local x = 0 -- offsetz
&#9;local function newlabel(text, font, color)
&#9;&#9;local new = Instance.new(&quot;TextLabel&quot;, root)

&#9;&#9;local xsize, ysize = Dim.TextSize(text, font, self.FontSize)
&#9;&#9;new.Size = UDim2.new(0,xsize,0,ysize)
&#9;&#9;new.TextColor3 = color
&#9;&#9;new.Text = text
&#9;&#9;new.Font = font
&#9;&#9;new.FontSize = self.FontSize
&#9;&#9;new.BackgroundTransparency = 1
&#9;&#9;new.Position = UDim2.new(1,x,0,0)
&#9;&#9;if not root then
&#9;&#9;&#9;root = new
&#9;&#9;else 
&#9;&#9;&#9;x = x + xsize
&#9;&#9;end
&#9;end
&#9;for item_id, item_data in pairs(list) do
&#9;&#9;local Text = item_data[1]
&#9;&#9;local Font = item_data[2]
&#9;&#9;local Color = item_data[3]
&#9;&#9;newlabel(Text, Font, Color)
&#9;end
&#9;return root
end

return ColorLabel</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX22">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Menu</string>
				<ProtectedString name="Source">local ButtonBar = Instinct.Include(&quot;Gui/ButtonBar&quot;)
local Palette = Instinct.Include(&quot;Utilities/Palette&quot;)
local SFX = Instinct.Include(&quot;Gui/SFX&quot;)
local WindowServer = Instinct.Include(&quot;Gui/WindowServer&quot;)
local DDMenu = Instinct.Include(&quot;Gui/DropDown&quot;)
local DimTools = Instinct.Include(&quot;Gui/DimTools&quot;)

local Player = game.Players.LocalPlayer

local Menu = {}

Menu.Offset = 4
Menu.YSize = 30
Menu.Shade = 2
Menu.BorderSize = 3
Menu.FontSize = &quot;Size14&quot;
Menu.LastDropDown = nil
Menu.LastDropDownButton = nil

function Menu:Init()
&#9;local Scr = Instance.new(&quot;ScreenGui&quot;, Player.PlayerGui)
&#9;Scr.Name = &quot;Menu&quot;
&#9;self.Root = Scr
&#9;local bar = Instance.new(&quot;Frame&quot;, Scr)
&#9;bar.Size=UDim2.new(0,0,0,self.YSize)
&#9;bar.BorderSizePixel = self.BorderSize
&#9;bar.BorderColor3 = Palette:Get(&quot;Default&quot;, &quot;Shade4&quot;)
&#9;bar.BackgroundColor3 = Palette:Get(&quot;Default&quot;, &quot;Shade2&quot;)
&#9;self.Bar = bar
&#9;-- create dropdown button
&#9;
end

function Menu:GetButton(type, openlist)
&#9;local DropDown = Instance.new(&quot;TextButton&quot;, self.Root)
&#9;local offset = self.YSize - self.Offset * 2
&#9;DropDown.BackgroundColor3 = Palette:Get(&quot;Complement&quot;)
&#9;DropDown.TextColor3 = Palette:Get(&quot;Text&quot;)
&#9;DropDown.Font = &quot;ArialBold&quot;
&#9;DropDown.FontSize = self.FontSize
&#9;DropDown.Text = &quot;V&quot;
&#9;DropDown.BorderSizePixel = 0
&#9;SFX.Shade(DropDown,self.Shade)
&#9;if type == &quot;DropDown&quot; and openlist then 
&#9;&#9;DropDown.MouseButton1Click:connect(function()
&#9;&#9;if self.LastDropDown then
&#9;&#9;&#9;self.LastDropDown:Destroy()
&#9;&#9;end
&#9;&#9;if self.LastDropDownButton == DropDown then
&#9;&#9;&#9;self.LastDropDownButton = nil
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;self.LastDropDownButton = DropDown
&#9;&#9;local new = Instinct.Create(Instinct.Gui.DropDown)
&#9;&#9;self.LastDropDown = new
&#9;&#9;new:Create(self.Root, UDim2.new(0,0,0, self.YSize + self.BorderSize), Palette:Get(&quot;Default&quot;, &quot;Shade1&quot;), Palette:Get(&quot;Default&quot;, &quot;Shade4&quot;), 
&#9;&#9;&#9;{&#9;which = DropDown,
&#9;&#9;&#9;&#9;left = false,
&#9;&#9;&#9;&#9;right = true,
&#9;&#9;&#9;&#9;up = false,
&#9;&#9;&#9;&#9;down = true,
&#9;&#9;&#9;&#9;bordersize = self.BorderSize,
&#9;&#9;})
&#9;&#9;for i,v in pairs(openlist) do 
&#9;&#9;&#9;local NewButton = new:AddButton(v)
&#9;&#9;&#9;NewButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;WindowServer.RequestOpen(NewButton.Text, NewButton)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;end)
&#9;else 
&#9;&#9;-- negotiate with winserver
&#9;&#9;local Window
&#9;&#9;DropDown.MouseButton1Click:connect(function() 
&#9;&#9;&#9;local xWindow = WindowServer.RequestOpen(DropDown.Text, DropDown)
&#9;&#9;
&#9;&#9;end)
&#9;end
&#9;return DropDown
end

function Menu:AddButton(button_name, type, openlist)
&#9;local button = self:GetButton(type or &quot;Window&quot;, openlist)
&#9;button.Text = button_name
&#9;local max = 0
&#9;for i,v in pairs(self.Root:GetChildren()) do
&#9;&#9;if v.Position.X.Offset + v.Size.X.Offset + self.Offset + self.Shade &gt; max then 
&#9;&#9;&#9;max = v.Position.X.Offset + v.Size.X.Offset + self.Offset + self.Shade
&#9;&#9;end
&#9;end
&#9;button.Position = UDim2.new(0,max,0,self.Offset)
&#9;local offset = self.YSize - self.Offset * 2
&#9;local x = DimTools.TextSize(button_name, button.Font, button.FontSize)
&#9;button.Size = UDim2.new(0, x + 10, 0, offset)
&#9;local nsize = max + button.Size.X.Offset + self.Offset + self.Shade
&#9;delay(1/30, function() self.Bar.Size = UDim2.new(0, nsize, 0, self.YSize) end)
end

return Menu </ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX23">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Console</string>
				<ProtectedString name="Source">local Console = {}

local Palette = Instinct.Include &quot;Utilities/Palette&quot;
local ScrollText = Instinct.Include &quot;Gui/ScrollText&quot;
local ButtonBar = Instinct.Include &quot;Gui/ButtonBar&quot;
local Dim = Instinct.Include &quot;Gui/DimTools&quot;

local Player = game.Players.LocalPlayer

Console.Seperator = &quot; :: &quot;
Console.Ready = false

function Console.Initialize()
&#9;print(Console.Ready)
&#9;if Console.Ready then
&#9;&#9;return
&#9;end
&#9;local new = Instance.new(&quot;ScreenGui&quot;, Player.PlayerGui)
&#9;new.Name = &quot;Console&quot;

&#9;local fr = Instance.new(&quot;Frame&quot;, new)
&#9;fr.BackgroundColor3 = Palette:Get(&quot;Shade1&quot;, &quot;Shade4&quot;)
&#9;fr.Size = UDim2.new(1,0,1,0)
&#9;fr.Name = &quot;Outer&quot;
&#9;fr.BorderSizePixel = 0
&#9;local win = Instance.new(&quot;Frame&quot;, fr)
&#9;win.Size = UDim2.new(1,-80,1,-80)
&#9;win.Position = UDim2.new(0,40,0,40)
&#9;win.BackgroundColor3 = Palette:Get(&quot;Console&quot;)
&#9;win.Name = &quot;Inner&quot;
&#9;Console.CRoot = new
&#9;Console.TerminalWindow = win
&#9;-- Create tab bar
&#9;local new = Instinct.Create(Instinct.Gui.ButtonBar)
&#9;local size_x, size_y = Dim.TextSize(&quot;test&quot;, new.Font, new.FontSize)
&#9;new:Init(Console.CRoot, UDim2.new(0,40, 1, -38), UDim2.new(1,-80,0,size_y + new.Shade))
&#9;Console.ButtonDock = new
&#9;Console.Tabs = {}
&#9;Console.Ready = true
end

function Console.Open()
&#9;Console.CRoot.Visible = true
end

function Console.Close()
&#9;Console.CRoot.Visible = false
end

function Console.Write(tab, prio, ...)
&#9;-- figure out if prio is an option or just text
&#9;--&gt; assertion: if prio is a table then it is an option!
&#9;if not Console.Tabs[tab] then
&#9;&#9;Console.CreateTab(tab)
&#9;end
&#9;local args
&#9;if type(prio) == &quot;table&quot; then
&#9;&#9;args = {...}
&#9;&#9;if prio == Instinct.Option.ConsolePriority.Extreme then 
&#9;&#9;&#9;-- MASTER WARNING open up the console
&#9;&#9;&#9;Console.Open()
&#9;&#9;end
&#9;else 
&#9;&#9;args = {prio, ...}
&#9;end
&#9;local t_args = {}
&#9;for i,v in pairs(args) do
&#9;&#9;t_args[i] = tostring(v)
&#9;end
&#9;local str = table.concat(t_args, Console.Seperator)
&#9;Console.Tabs[tab][1]:Push(&quot;[ %{light cyan bold} &quot;..math.floor(os.time() + 0.5)..&quot; %{reset}] &quot;..str, Palette:Get(&quot;ColorLabel&quot;, &quot;white&quot;))
end

function Console.OpenTab(tab)
&#9;if Console.TabOpen then
&#9;&#9;Console.Tabs[Console.TabOpen][1].Root.Visible = false
&#9;&#9;Console.Tabs[Console.TabOpen][2].BackgroundColor3 = Palette:Get(&quot;Complement&quot;)
&#9;end
&#9;if Console.Tabs[tab] then
&#9;&#9;Console.TabOpen = tab
&#9;&#9;Console.Tabs[tab][1].Root.Visible = true
&#9;&#9;Console.Tabs[tab][2].BackgroundColor3 = Palette:Get(&quot;Shade1&quot;)
&#9;end
end

function Console.CreateTab(tab)
&#9;if Console.Tabs[tab] then
&#9;&#9;return
&#9;end
&#9;local b = Console.ButtonDock:AddButton(tab)

&#9;Console.Tabs[tab] = {Instinct.Create(ScrollText),b}
&#9;Console.Tabs[tab][1].FontSize = &quot;Size18&quot;
&#9;Console.Tabs[tab][1].TextColor = Palette:Get(&quot;Console&quot;, &quot;Text&quot;)
&#9;Console.Tabs[tab][1]:Create(Console.TerminalWindow)
&#9;Console.Tabs[tab][1]:Push(&quot; --- &quot;..tab..&quot; ---&quot;, Palette:Get(&quot;ColorLabel&quot;, &quot;white&quot;))
&#9;Console.Tabs[tab][1].Root.Visible = false
&#9;
&#9;b.MouseButton1Click:connect(function()
&#9;&#9;if Console.TabOpen then
&#9;&#9;&#9;Console.Tabs[Console.TabOpen][1].Root.Visible = false
&#9;&#9;&#9;Console.Tabs[Console.TabOpen][2].BackgroundColor3 = Palette:Get(&quot;Complement&quot;)
&#9;&#9;end
&#9;&#9;Console.TabOpen = tab
&#9;&#9;Console.Tabs[tab][1].Root.Visible = true
&#9;&#9;b.BackgroundColor3 = Palette:Get(&quot;Shade1&quot;)
&#9;end)
&#9;
&#9;return Console.Tabs[tab][1]
end

return Console</ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX24">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">LocaleFiles</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX25">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Francais</string>
					<ProtectedString name="Source">local Locale = {

&#9;
&#9;
}

return Locale
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX26">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Deutsch</string>
					<ProtectedString name="Source">local Locale = {

&#9;
&#9;
}

return Locale
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX27">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">English</string>
					<ProtectedString name="Source">local Locale = {
&#9;MENU_BACKPACK = &quot;Backpack&quot;,
&#9;MENU_TRIBE = &quot;Tribe&quot;,
&#9;MENU_RECIPES = &quot;Recipes&quot;,
&#9;MENU_HELP = &quot;Help&quot;,
&#9;MENU_CONSOLE = &quot;Console&quot;,
&#9;MENU_ADMINISTRATION = &quot;Administration&quot;,
&#9;MENU_SERVER = &quot;Server&quot;
&#9;
&#9;
}

return Locale
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX28">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Espanol</string>
					<ProtectedString name="Source">local Locale = {

&#9;
&#9;
}

return Locale
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX29">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Italiano</string>
					<ProtectedString name="Source">local Locale = {

&#9;
&#9;
}

return Locale
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX30">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Nederlands</string>
					<ProtectedString name="Source">local Locale = {
&#9;MENU_BACKPACK = &quot;Rugzak&quot;,
&#9;MENU_TRIBE = &quot;Stam&quot;,
&#9;MENU_RECIPES = &quot;Recepten&quot;,
&#9;MENU_HELP = &quot;Hulp&quot;,
&#9;MENU_CONSOLE = &quot;Console&quot;,
&#9;MENU_ADMINISTRATION = &quot;Administratie&quot;,
&#9;MENU_SERVER = &quot;Server&quot;,
&#9;
&#9;
}

return Locale
</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Script" referent="RBX31">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Event</string>
				<ProtectedString name="Source">local Event = {}

function Event:Call()
&#9;self:fire()
end

function Event:Constructor()
&#9;self.List = {}
end

function Event:connect(func)
&#9;table.insert(self.List, func)
&#9;local ret = {}
&#9;function ret:disconnect()
&#9;&#9;for i,v in pairs(self.List) do
&#9;&#9;&#9;if v == func then
&#9;&#9;&#9;&#9;self.List[i] = nil
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return ret
end

function Event:fire(...)
&#9;local args = {...}
&#9;for i,v in pairs(self.List) do 
&#9;&#9;delay(0, function() v(unpack(args)) end)
&#9;end
end

function Event:wait()
&#9;-- well well well HOW IN THE WORLD ARE WE GOING TO DO THIS!?
&#9;--&gt; BUSY WAIT!? (no?)
&#9;--&gt; any kind of awesome coroutine hack?
end

return Event</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX32">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Content</string>
				<ProtectedString name="Source">local Content = {}

function Content:WaitForContent()
&#9;Instinct.Console.CreateTab &quot;Core&quot;
&#9;local last = game:GetService(&quot;ContentProvider&quot;).RequestQueueSize
&#9;while game:GetService(&quot;ContentProvider&quot;).RequestQueueSize &gt; 0 do
&#9;&#9;wait()
&#9;&#9;if game:GetService(&quot;ContentProvider&quot;).RequestQueueSize ~= last then
&#9;&#9;&#9;last = game:GetService(&quot;ContentProvider&quot;).RequestQueueSize
&#9;&#9;&#9;Instinct.Console.Write(&quot;Core&quot;, &quot;ContentProvider: Queue: &quot;..game:GetService(&quot;ContentProvider&quot;).RequestQueueSize)
&#9;&#9;end
&#9;end
end

return Content</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX33">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MainMenu</string>
				<ProtectedString name="Source">-- MainMenu provides the main menu for the game
-- Additional modules can be launched from here
-- Insertion points are provided

local MainMenu = {}

MainMenu.TitleFont = &quot;ArialBold&quot;
MainMenu.FontSize = &quot;Size36&quot;
MainMenu.TitleShade = 3

MainMenu.BarSize = 4
MainMenu.BarOffset = 3
MainMenu.BarColor = Palette:Get() 
MainMenu.BarScale = 0.8 -- 80% of the original size

MainMenu.TextWhiteSpace = 10

MainMenu.ButtonFont = &quot;ArialBold&quot;
MainMenu.ButtonFontSize = &quot;Size24&quot;

MainMenu.WhiteSpace = 20
MainMenu.ButtonShading = 2 -- wow so much shading
MainMenu.XOffset = 50

local Palette = Instinct.Include &quot;Utilities/Palette&quot;
local Locale = Instinct.Include &quot;Services/Locale&quot;
local Presets = Instinct.Include &quot;Gui/GuiPresets&quot;
local Dim = Instinct.Include &quot;Gui/DimTools&quot;

local Player = game.Players.LocalPlayer

function MainMenu.CreateFromList(title, list) -- creates the main menu from gui items
&#9;local VERSION = Instinct.Include &quot;Version&quot;
&#9;local Root = Instance.new(&quot;ScreenGui&quot;, Player.PlayerGui)
&#9;local Backdrop = Presets.Backdrop(5)
&#9;local MMLabel, x, y = Presets.CustomButton(
&#9;&#9;title,&#9;&#9;MainMenu.TitleShade, MainMenu.TitleFont, MainMenu.FontSize, 
&#9;&#9;Palette:Get(&quot;Text&quot;), Palette:Get(&quot;Complement&quot;), 
&#9;&#9;MainMenu.TextWhiteSpace) 
&#9;local curry = MainMenu.WhiteSpace
&#9;Backdrop.Parent = Root
&#9;MMLabel.Parent = Backdrop
&#9;local curry = curry + y + MainMenu.WhiteSpace
&#9;MMLabel.Position = UDim2.new(0.5, -x/2, 0, MainMenu.WhiteSpace)
&#9;local max_x = x
&#9;for i,v in pairs(list) do
&#9;&#9;local DeltaY = -( MainMenu.TextWhiteSpace - MainMenu.BarOffset )
&#9;&#9;local inspos = curry + DeltaY 
&#9;&#9;local new = Instance.new(&quot;Frame&quot;, BackDrop)
&#9;&#9;local b,x,y = Presets.CustomButton(v, MainMenu.ButtonShading, MainMenu.ButtonFont, 
&#9;&#9;&#9;MainMenu.ButtonFontSize, Palette:Get(&quot;Text&quot;), Palette:Get(&quot;Complement&quot;, &quot;Shade2&quot;), 
&#9;&#9;&#9;MainMenu.TextWhiteSpace
&#9;&#9;)
&#9;&#9;b.Parent = Backdrop
&#9;&#9;b.Position = UDim2.new(0.5, -x/2, 0, curry)
&#9;&#9;curry = curry + y + MainMenu.WhiteSpace
&#9;&#9;if x &gt; max_x then
&#9;&#9;&#9;x = max_x
&#9;&#9;end
&#9;end
&#9;
&#9;Backdrop.Size = UDim2.new(0, max_x + MainMenu.WhiteSpace, 0, curry)
&#9;Backdrop.Position = UDim2.new(1,-(max_x + MainMenu.WhiteSpace) - MainMenu.XOffset, 0.5, -curry/2)
end


return MainMenu</ProtectedString>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX34">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">World</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Script" referent="RBX35">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Tree</string>
					<ProtectedString name="Source">-- Tree is used in Stranded to generate trees
-- Please note that this version is limited.

local Fruit = Instinct.Include &quot;World/Fruit&quot;

local Tree = {}

-- How much branches must the tree have?
-- Note: no depth!

Tree.MinBranches = 2
Tree.MaxBranches = 4

-- The y component of these must be 1
-- You can always do this as this is just some ratio.

Tree.FoliageSize = Vector3.new(0.25,1,0.25)
Tree.FoliageSizeMax = Vector3.new(0.35, 1, 0.35)

Tree.BaseSize = Vector3.new(0.3, 1, 0.3)
Tree.BaseSizeMax = Vector3.new(0.4, 1, 0.4)
Tree.StartHeight = 1

Tree.FoliagePortion = 0.5

Tree.MinHeight = 8
Tree.MaxHeight = 10

Tree.GrowTime = 600 -- 10 minutes

Tree.BranchSizeShiftMin = 0.6
Tree.BranchSizeShiftMax = 0.9

Tree.BranchGrowRate = 0.75

Tree.MinimumCenterRotation = 30 -- Degrees minimum rotation.

Tree.BendMin = 20
Tree.BendMax = 40

-- Colors

Tree.TrunkColor = BrickColor.new(&quot;Brown&quot;)
Tree.FoliageColor = BrickColor.new()

Tree.Fruit = nil

function Tree:UpdateWeld(part1, part2, c1, c2)
&#9;if part1:FindFirstChild(&quot;Weld&quot;) then
&#9;&#9;part1.Weld:Destroy()
&#9;end
&#9;local Weld = Instance.new(&quot;Weld&quot;, part1)
&#9;Weld.Name = &quot;Weld&quot;
&#9;Weld.Part0 = part2
&#9;Weld.Part1 = part1
&#9;Weld.C0 = c2:toObjectSpace(c1)
end

function Tree:GetRandomVector(min,max)
&#9;local xmin,ymin,zmin = min.x, min.y, min.z
&#9;local xmax,ymax,zmax = max.x, max.y, max.z
&#9;local function calc(min,max)
&#9;&#9;return min + math.random() * (max-min)
&#9;end
&#9;local x = calc(xmin, xmax)
&#9;local y = calc(ymin,ymax)
&#9;local z = calc(zmin,zmax)
&#9;return Vector3.new(x,y,z)
end

-- Initializes the tree;
-- Generates a base
-- DOES NOT USE CONSTRUCTOR SO USER CAN DEFINE ITS OWN PROPERTIES OF THE TREE!
function Tree:Initialize()
&#9;self.StartTime = tick()&#9;
&#9;
&#9;local base = Instance.new &quot;Part&quot;
&#9;base.TopSurface = &quot;Smooth&quot;
&#9;base.BottomSurface = &quot;Smooth&quot;
&#9;base.BrickColor = self.TrunkColor
&#9;base.FormFactor = &quot;Custom&quot;

&#9;
&#9;Instance.new(&quot;CylinderMesh&quot;, base)
&#9;self.Base = base
&#9;
&#9;
&#9;local foliage = Instance.new &quot;Part&quot;
&#9;foliage.BrickColor = self.FoliageColor
&#9;foliage.BottomSurface = &quot;Smooth&quot;
&#9;foliage.TopSurface = &quot;Smooth&quot;
&#9;foliage.FormFactor = &quot;Custom&quot;
&#9;self.Foliage = foliage
&#9;
&#9;local bs = self:GetRandomVector(self.BaseSize, self.BaseSizeMax)
&#9;local fs = self:GetRandomVector(self.FoliageSize, self.FoliageSizeMax)
&#9;
&#9;base.Size = bs
&#9;foliage.Size = fs
&#9;
&#9;self.BaseSize = bs
&#9;self.FoliageSize = bs
&#9;
&#9;self.TargetHeight = self.MinHeight + math.random() * (self.MaxHeight - self.MinHeight)
end

-- Returns a vector which has y = 1, ratios are ok
-- Sorta unit vector.
-- Can be used to restore tree memory.
-- Or to generate branches :)
function Tree:GetVectorRatio(vector)
&#9;local y = vector.y&#9;
&#9;return vector/y
end

function Tree:GetRotationArray(NBranches) -- Input Number of branches you want to spawn, get Y rotation array.
&#9;local NBranches = NBranches or self.Branches&#9;
&#9;--local random_offset = math.random(1,360)  --Creates a random offset.
&#9;local plus_minimum = self.MinimumCenterRotation
&#9;local plus_maximum = (360/NBranches) - self.MinimumCenterRotation
&#9;local list_out = {} 
&#9;for angle = 1, NBranches do
&#9;&#9;list_out[angle] = math.rad( math.random(plus_minimum, plus_maximum) + (360/NBranches) * (angle - 1) )
&#9;end
&#9;return list_out
end

function Tree:CreateFoliage(branch)
&#9;local y = branch.Size.y
&#9;local myheight = y * self.FoliagePortion
&#9;local size = self.FoliageSize * myheight
&#9;local new = self.Foliage:Clone()
&#9;new.Parent = branch
&#9;new.Size = size
&#9;new.CFrame = branch.CFrame * CFrame.new(0, branch.Size.y/2, 0)
end

function Tree:CreateBranch(Rotation)
&#9;&#9;local base = self.Base
&#9;&#9;local new = base:Clone()
&#9;&#9;table.insert(newBranches, new)
&#9;&#9;local ds = self.BranchSizeShiftMax - self.BranchSizeShiftMin
&#9;&#9;local RandSize = self.BranchSizeShiftMin + ds * math.random()
&#9;&#9;
&#9;&#9;local newx = base.Size.x * RandSize&#9;&#9;
&#9;&#9;
&#9;&#9;local NewSize = Vector3.new(newx,base.Size.y,newx) * self.BranchGrowRate
&#9;&#9;
&#9;&#9;local CF = BaseTop * CFrame.new(0, base.Size.y/2, 0)
&#9;&#9;
&#9;&#9;local rotate = self.BendMin + math.random() * (self.BendMax-self.BendMin)
&#9;&#9;
&#9;&#9;CF = CF * CFrame.Angles(0,math.rad(Rotation), math.rad(rotate)) * CFrame.new(0,NewSize.y,0) 
&#9;&#9;new.Parent = self.TreeBase 
&#9;&#9;
&#9;&#9;self:UpdateWeld(base, new, base.CFrame, new.CFrame)
&#9;&#9;return new
end

function Tree:Place(Ground, CF)
&#9;local base = self.Base:Clone()
&#9;self.TreeBase = base
&#9;base.Parent = game.Workspace.Life
&#9;local h = self.StartHeight * self.BaseSize
&#9;base.Size = h 
&#9;base.CFrame = CF * CFrame.new(0, base.Size.y/2, 0) 
&#9;self:UpdateWeld(Ground, base, Ground.CFrame, base.CFrame)
&#9;self.Branches = math.random(self.MinBranches, self.MaxBranches)
&#9;local Rotations = self:GetRotationArray()
&#9;self.Rotations = Rotations
&#9;local BaseTop = base.CFrame * CFrame.new(0, base.Size.y/2,0)
&#9;local newBranches = {}
&#9;for branch = 1, self.Branches do 
&#9;&#9;local new = self:CreateBranch(Rotations[branch])
&#9;&#9;table.insert(newBranches, new)
&#9;&#9;Rotations[branch] = {Rotation, new, self.StartTime}
&#9;end
&#9;for _, branch in pairs(newBranches) do 
&#9;&#9;branch.Parent = base
&#9;&#9;self:CreateFoliage(branch)
&#9;end
end

function Tree:GetNewHeightPortion(StartTime)
&#9;local dt = tick() - (StartTime or self.StartTime)
&#9;if dt &gt; self.GrowTime then
&#9;&#9;return 1
&#9;end
&#9;local func = function(x)
&#9;&#9;return (-1 * (((x/self.GrowTime)-1)^2) + 1) 
&#9;end
&#9;return func(dt)
end

function Tree:CreateFoliage(branch)
&#9;local y = branch.Size.y
&#9;local foliage_y = self.FoliagePortion * y 
&#9;local foliagesize = foliage_y * self.FoliageSize
&#9;local foliage = self.Foliage:Clone()
&#9;foliage.Parent = branch
&#9;local btop = branch.CFrame * CFrame.new(0, branch.Size.y/2, 0)
&#9;foliage.Size = foliagesize
&#9;self:UpdateWeld(branch, foliage, branch.CFrame, btop)&#9;
end

function Tree:UpdateFoliage(branch, foliage)
&#9;local y = branch.Size.y
&#9;local foliage_y = self.FoliagePortion * y 
&#9;local foliagesize = foliage_y * self.FoliageSize
&#9;foliage.Parent = branch
&#9;local btop = branch.CFrame * CFrame.new(0, branch.Size.y/2, 0)
&#9;foliage.Size = foliagesize
&#9;self:UpdateWeld(branch, foliage, branch.CFrame, btop)&#9;
end

function Tree:Grow()
&#9;-- First update the base.
&#9;local newheight = self:GetNewHeightPortion()
&#9;if not self.BaseFinishedGrowing then 
&#9;&#9;local height = newheight * self.TargetHeight
&#9;&#9;if newheight == 1 then
&#9;&#9;&#9;self.BaseFinishedGrowing = true
&#9;&#9;end
&#9;end
&#9;for i,v in pairs(self.Rotations) do
&#9;&#9;if v[2].Parent ~= self.TreeBase then
&#9;&#9;&#9;local new = self:CreateBranch(v[1])
&#9;&#9;&#9;v[2] = new
&#9;&#9;&#9;v[3] = tick()
&#9;&#9;end
&#9;&#9;if v[2].Size.y &lt; self.BranchGrowRate * self.TargetHeight then 
&#9;&#9;&#9;local ratio = self:GetVectorRation(v[2].Size)
&#9;&#9;&#9;local th = self.BranchGrowRate * self.TargetHeight
&#9;&#9;&#9;local portion = self:GetNewHeightPortion(v[3])
&#9;&#9;&#9;local newheight = th * portion
&#9;&#9;&#9;local newsize = ratio * newheight
&#9;&#9;&#9;local dy = newsize.y - v[2].Size.y 
&#9;&#9;&#9;v[2].Size = newsize
&#9;&#9;&#9;self:UpdateWeld(self.TreeBase, v[2], self.TreeBase.CFrame, v[2].CFrame * CFrame.new(0, dy/2,0))
&#9;&#9;end
&#9;&#9;self:UpdateFoliage(v[2])
&#9;end
&#9;
end

return Tree </ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX36">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TreePlacement</string>
					<ProtectedString name="Source">-- Tree placement generator
-- Maps the world as a line; places trees on this line

local TreePlacement = {}

return TreePlacement</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX37">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WorldTools</string>
					<ProtectedString name="Source">-- World Tools provides a toolkit
-- for &quot;world operations&quot; such as
-- collission checking.

local WorldTools = {}

return WorldTools</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX38">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Fruit</string>
					<ProtectedString name="Source">-- Fruit is a special resource type
-- It has a Grow function
-- Can also be used as vegetables ^_^

-- The Tree Instance will handle all positions;
-- 
local Fruit = {}

Fruit.LastTick = 0
Fruit.Base = nil

-- This fucntion should be user defined
-- It should return a base
function Fruit:GetBase()
&#9;return Instance.new(&quot;Part&quot;) 
end

-- Fruit doesnt have regular growing patterns
-- This function should also be user provided
-- This whole class is user defined ._.

function Fruit:GrowBase(dt)
&#9;
&#9;
end

-- the dt argument is delta time since last
-- intern clock is provided and used when dt is nil
function Fruit:Grow(dt)
&#9;local dt = dt or (tick() - self.LastTick)
&#9;self:GrowBase(dt)
&#9;self.LastTick = tick()&#9;
end



return Fruit</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>